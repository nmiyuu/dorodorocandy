using UnityEngine;
using UnityEngine.SceneManagement;
using System.Collections;
using System.Linq;

public class TimeTravelController : MonoBehaviour
{
    // --- シーン名設定 (Inspectorで設定) ---
    public string pastSceneName = "Stage1_Past";
    public string presentSceneName = "Stage1_now";

    private bool isSwitchingScene = false;
    private GameObject playerObject;
    private t_pl playerScriptRef; // スプライト制御用
    private t_player playerMovementScript; // ★追加: 移動制御用
    private BoxCollider2D playerColliderRef;
    private LayerMask obstacleLayer;

    private bool TrySetPlayerReferences()
    {
        if (playerObject == null)
        {
            playerObject = GameObject.FindGameObjectWithTag("Player");
        }

        if (playerObject != null && playerScriptRef == null)
        {
            playerScriptRef = playerObject.GetComponent<t_pl>();

            // t_player（移動制御）の参照を取得
            playerMovementScript = playerObject.GetComponent<t_player>();

            if (playerScriptRef != null && playerMovementScript != null)
            {
                playerColliderRef = playerObject.GetComponent<BoxCollider2D>();
                obstacleLayer = playerMovementScript.obstacleLayer; // t_playerからLayerMaskを取得
            }
            else
            {
                if (playerScriptRef == null) Debug.LogError($"Playerオブジェクト '{playerObject.name}' に t_pl スクリプトが見つかりません。");
                if (playerMovementScript == null) Debug.LogError($"Playerオブジェクト '{playerObject.name}' に t_player スクリプト（移動制御）が見つかりません。移動中チェックは機能しません。");
            }
        }
        return playerObject != null && playerScriptRef != null && playerColliderRef != null && playerMovementScript != null;
    }

    void Start()
    {
        TrySetPlayerReferences();
        if (playerObject == null)
        {
            Debug.LogError("タグが 'Player' のオブジェクトが見つかりません。TimeTravelControllerが動作しません。");
        }
    }

    void Update()
    {
        if (isSwitchingScene) return;
        if (!TrySetPlayerReferences()) return;

        // 移動中チェックを追加
        if (playerMovementScript.IsPlayerMoving) return;

        if (Input.GetKeyDown(KeyCode.Space))
        {
            StartCoroutine(TrySwitchTimeLine());
        }
    }

    private void SetSceneRenderingEnabled(Scene scene, bool isEnabled)
    {
        foreach (GameObject rootObject in scene.GetRootGameObjects())
        {
            foreach (Renderer renderer in rootObject.GetComponentsInChildren<Renderer>(true))
            {
                renderer.enabled = isEnabled;
            }
        }
    }


    public IEnumerator TrySwitchTimeLine()
    {
        isSwitchingScene = true;

        // コルーチン開始直後にもう一度移動中チェック
        if (playerMovementScript.IsPlayerMoving)
        {
            isSwitchingScene = false;
            yield break;
        }

        Scene currentScene = SceneManager.GetActiveScene();
        string currentSceneName = currentScene.name;
        string nextSceneName = string.Empty;

        Vector3 nextPlayerPosition = playerObject.transform.position;

        // データの保存と次のシーン名の決定
        if (currentSceneName == presentSceneName)
        {
            nextSceneName = pastSceneName;
        }
        else if (currentSceneName == pastSceneName)
        {
            nextSceneName = presentSceneName;
            if (SceneDataTransfer.Instance != null)
            {
                SceneDataTransfer.Instance.SaveBlockPositions();
            }
        }
        else
        {
            Debug.LogWarning("未定義のシーンです: " + currentSceneName);
            isSwitchingScene = false;
            yield break;
        }

        // プレイヤーの復帰位置と向きをデータ転送オブジェクトに保存
        if (SceneDataTransfer.Instance != null)
        {
            SceneDataTransfer.Instance.playerPositionToLoad = nextPlayerPosition;

            // ★修正: 現在の向きをデータ転送オブジェクトに保存
            SceneDataTransfer.Instance.playerDirectionToLoad = playerScriptRef.CurrentDirection;
        }

        // 1. 新しいシーンを非同期でロード
        AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(nextSceneName, LoadSceneMode.Additive);
        while (!asyncLoad.isDone)
        {
            yield return null;
        }

        Scene nextScene = SceneManager.GetSceneByName(nextSceneName);
        if (!nextScene.IsValid())
        {
            Debug.LogError("シーンの追加ロードに失敗しました: " + nextSceneName);
            isSwitchingScene = false;
            yield break;
        }

        // 2. 新しいシーンの描画をすぐに抑制
        SetSceneRenderingEnabled(nextScene, false);

        // 3. 新しいシーンをアクティブシーンに設定（Start() / Awake() が実行される）
        SceneManager.SetActiveScene(nextScene);

        // 4. ブロックの配置と物理演算の安定を待つ
        yield return new WaitForFixedUpdate();
        yield return new WaitForEndOfFrame();
        yield return null;

        // 5. プレイヤー参照の再取得
        playerObject = null;
        playerScriptRef = null;
        playerColliderRef = null;
        playerMovementScript = null;

        if (!TrySetPlayerReferences())
        {
            Debug.LogError("新しいシーンでプレイヤーオブジェクトが見つかりませんでした。");
            isSwitchingScene = false;
            yield break;
        }

        // 6. 衝突判定
        if (playerColliderRef != null)
        {
            Collider2D hitCollider = Physics2D.OverlapBox(
                (Vector2)nextPlayerPosition + playerColliderRef.offset,
                playerColliderRef.size,
                0f,
                obstacleLayer
            );

            // 7. 衝突判定後の処理
            if (hitCollider != null)
            {
                Debug.LogWarning($"タイムトラベル中止: 復帰位置({nextPlayerPosition})に障害物('{hitCollider.gameObject.name}')があります。");

                SceneManager.SetActiveScene(currentScene);

                AsyncOperation unloadOp = SceneManager.UnloadSceneAsync(nextScene);
                while (!unloadOp.isDone)
                {
                    yield return null;
                }

                yield return null;

                isSwitchingScene = false;
                Debug.Log("切り替えがキャンセルされました。");
                yield break;
            }
        }

        // 8. 成功した場合のみ、描画を有効にし、古いシーンをアンロード
        SetSceneRenderingEnabled(nextScene, true); // 新しいシーンの描画を開始

        AsyncOperation unloadOldScene = SceneManager.UnloadSceneAsync(currentSceneName);
        while (!unloadOldScene.isDone)
        {
            yield return null;
        }

        // 9. 完了後の最終処理

        // ★修正: 復元処理をWaitForFixedUpdateの直後にすることで、t_pl.Start()やUpdate()の実行を確実に見送る
        yield return new WaitForFixedUpdate();

        if (SceneDataTransfer.Instance != null && playerScriptRef != null)
        {
            // 保存された向きをロード
            playerScriptRef.LoadDirection(SceneDataTransfer.Instance.playerDirectionToLoad);
            Debug.Log($"プレイヤーの向きを {SceneDataTransfer.Instance.playerDirectionToLoad} に復元しました。");
        }

        isSwitchingScene = false;
        Debug.Log($"シーン切り替え完了: {nextSceneName}。次の入力可能です。");
    }
}